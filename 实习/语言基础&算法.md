## 语言基础&算法

__c和c++的区别__

- c面向过程语言，性能高，但是不方便维护与扩展；c++面向对象的语言，可以设计出高内聚低耦合的系统，便于维护和复用

- 文件后缀名不同

- 不支持重载与支持重载

- 关键字不同

__c++和python的区别__

- 编译型语言与解释型语言



__多态__

介绍一下c++多态

- 通过基类的指针或引用调用虚函数，并且该虚函数已经完成了对基类虚函数的重写，此时就构成了多态。

多态实现的原理

- 通过虚函数表实现多态。在含有虚函数的类的每个对象里都包含了一个虚函数指针，指针指向虚函数表，虚函数表里存放了虚函数的地址。子类继承父类时会复制一份父类的虚函数表，如果在子类中完成了对虚函数的重写，会在子类的虚函数表中更改对应的虚函数地址，新定义的虚函数会按照声明顺序放在虚函数表后面。当继承自多个类时会继承多个虚函数表，有多个虚函数指针，新定义的虚函数放在第一个虚函数表后面。这样在通过基类指针或引用调用虚函数时，会根据传进来的对象的虚表指针查找虚函数表，然后再找到对应的虚函数，从而实现多态。

构造函数和析构函数可以是虚函数吗



__解决哈希冲突的方法__

- 外部拉链法：基于数组和链表的组合来解决冲突。当产生冲突时将冲突的键值对插入到链表中
- 开放定址法：发生冲突后直接去寻找下一个空的地址，又包含了线性探测、平方探测和随机探测
- 公共溢出区：建立一个独立的公共区，把冲突的键值对都放在里面
- 再hash法：换另外一个hash函数来计算hash值



__右值引用和完美转发__

可以放在等式左边的即为左值，左值在内存中长久保存，可以取地址；右值是表达式结束产生的临时量，不能放在等式左边，不可以取地址，一般保存在寄存器中



__静态链接和动态链接__

静态链接就是在链接时将所有需要的目标文件都加入到最终的可执行程序中，而动态链接则将这一过程推迟到了程序运行时

静态链接浪费空间，因为每个需要目标文件的程序都会在最终可执行程序中包含该目标文件的一个副本；此外更新困难，需要重新编译链接；动态链接把链接过程推迟到运行期，性能会有一定损失。



__野指针和悬空指针__

野指针是没有初始化的指针，指向不合法的内存空间；悬空指针是指指针指向的内存空间已被释放或不再有效



__内存对齐__

- _什么是内存对齐_

计算机对数据在内存中的存放位置有一定的限制，要求这些数据的首地址的值是某个数的倍数

- _为什么要内存对齐_

提高数据存取效率，处理器每次存取数据为4字节、8字节甚至16字节，有了内存对齐后处理器可以一次就将数据取出来，不用做额外的处理

- _对齐规则_

对齐系数：编译器的默认对齐数值，可以通过预编译命令 #pragma pack(n) 进行改变

有效对齐数：对齐系数与结构体中最长数据类型长度中较小的那个



简洁解释:

基本数据类型的对齐值为其sizeof大小

结构体的对齐值为其成员的最大对齐值

考虑编译器的默认对齐值后，各个类型的实际对齐值为该类型的对齐值与默认对齐值的最小值



__智能指针__

__四种强制类型转换__

__union类型__

是一种特殊的数据类型，联合中的成员共享同一块内存空间，改变一个成员的值会影响其他成员的值，联合类型的大小为成员大小的最大值。可利用union特性判断机器大小端模式

__大端存储与小端存储__

指的是字节顺序与存储顺序的两种对应模式，大端存储情况下低地址存储高字节数据，小端存储情况下低地址存储低字节数据

大端存储容易判断正负，小端存储容易进行类型转换

- _如何判断机器大端存储还是小端存储_

利用Union，存储int、char，int写入数据，char查看低地址数据内容

---

__各种排序算法极其复杂度退化情况__

堆排序

快排

桶排序

归并排序



__map和hashmap区别__

map包括treemap和hashmap，treemap底层用红黑树实现，数据是有序的，对应c++的map，优点是空间要求低，但是时间上不如hashmap；hashmap底层用哈希实现，数据是无序的，对应c++的unordered_map，优点是查找速度快，但是比较浪费空间

---

__如何理解python一切皆对象__

---

__linux常用操作命令__

---

__怎么判断链表是否有环__

__12个铁球称三次找出不同的一个__

---

