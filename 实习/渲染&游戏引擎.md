## 渲染&游戏引擎 ##

__光栅化渲染流程__

- 应用程序阶段：cpu准备数据传给gpu

- 几何阶段

1. 顶点着色器 

​       逐顶点处理数据

2. 几何着色器

​       逐图元处理，可以删除或增加一些顶点以实现一些特殊效果

3. 裁剪空间裁剪

​       裁剪掉视锥外多余部分

4. 屏幕映射

​       将坐标变化到屏幕坐标系

- 光栅化阶段(将图元转变为一个二维图像的过程)

​       三角形设定与遍历

​       像素着色器



__判断点是否在三角形内__

1. 叉乘法
2. 面积求和法
3. 重心坐标法
4. 叉乘判断是否在同侧法



__前向渲染和延迟渲染的区别__

- 简单概括，前向渲染就是先计算光照再裁剪，延迟渲染就是先裁剪再计算光照
- early-z 和 z-prepass 一定程度上缓解了无效光照计算的问题，但还是基于前向渲染
- 不同于 z-prepass，延迟渲染在计算完深度信息后会保存shading所需要的信息到G-buffer中，然后逐像素计算光照。
- 对于几何物体数量N和光照数量M，两者复杂度分别是 N*M 和 N+M



- 通常的前向渲染包含大量的overdraw，即存在同一个像素被多次绘制并覆盖的情况，这样就导致了大量的无效计算，为了解决这个问题，延迟渲染使用了两个pass，第一个pass进行深度测试，并保存通过了深度测试的片元的法线、位置、材质属性等光照计算相关的信息，这些数据保存在GBuffer里面，第二个pass则利用GBuffer中的信息逐像素计算光照
- 假设场景中包含N个光源和M个物体，前向渲染的时间复杂度是 N*M，而延迟渲染的时间复杂度是 N+M
- early-z 与 z-prepass 都是为了解决 overdraw 而提出来的方案，但是其本质上还是前向渲染，时间复杂度仍然为 N*M
- early-z是更换深度测试与光照计算的顺序，先进行深度测试，通过测试的再光照计算，这种方法最好是对场景中的物体由近及远进行渲染，效果最佳，但是这就需要CPU对物体深度进行排序，比较耗费时间
- z-prepass类似与延迟渲染，第一个pass开启深度测试和深度写入，只更新场景的深度缓存，而在第二个pass关闭深度写入，深度测试条件变为深度相同，需要配合early-z一起使用



__光照模型__

- __Lambert光照模型__

只考虑环境光和漫反射部分，漫反射部分为什么有余弦项？因为表面光强依赖于光线入射方向和物体表面法线向量的夹角，光线垂直于物体表面时，漫反射光强最大；光线与物体表面平行时，漫反射光为0

- __phong光照模型__

增加了对镜面反射效果的模拟，认为镜面反射的光强与反射光线和视线的夹角有关

- __BlinnPhong光照模型__

对phong光照模型的计算进行优化，高光部分不再计算视线方向和入射光反射方向的夹角，而计算着色点法线方向和半程向量之间的夹角



__着色模型__

- __Gouraud着色__

在顶点着色器计算顶点光照，然后再插值得到片元颜色

- __phong着色__

插值得到每个片元的光源方向和法线方向，然后在片元着色器计算每个片元的颜色



__渲染架构__

移动端使用TBR，即 tile based rendering，对整个 framebuffer 分块绘制，绘制好整个tile后再拷贝到 framebuffer 对应位置上

PC端使用IMR，即 immediate mode rendering



---

__介绍一下光线追踪__

是和光栅化渲染相对应的另一种场景渲染方式。具体来说就是，对于图像中的每一个像素，从相机的位置出发经过该像素向场景中投射一根光线，光线与场景相交则计算交点处的颜色作为该像素的颜色。光线还可以根据物理规律和材质特性进行反射、折射，打到场景中其他点则叠加上该点处的颜色



__光线追踪和路径追踪区别__

- 光线追踪  Ray Tracing
- 1. 实际上是一个框架，符合该框架的都叫Ray Tracing。从视点发射光线，与物体相交就根据规则反射、折射或吸收。遇到光源或者走太远就停住。一般来说运算量不小。
- 2. 光线投射 Ray Casting：是Ray Tracing的第一步，发射光线，与物体相交。
- 路径追踪 Path Tracing：是Ray Tracing + 蒙特卡洛法。在相交后会选一个随机方向继续跟踪，并根据BRDF计算颜色



__光线追踪中计算光线与场景交点__

- __划分包围盒__

逐个三角形计算是否与光线相交太过浪费计算资源，可以划分层级包围盒，先判断是否与较大包围盒相交，不相交的话则肯定与大包围盒中所有三角面不相交，相交的话再递归计算与每个小包围盒是否相交，使用AABB轴对齐包围盒，即三对面组成的立方体包围三角面

- __BVH层次包围盒__

递归划分包围盒时，选择最长的轴进行划分，并且选择中间位置的三角面划分，这样会尽可能的使树接近平衡二叉树，划分到一个比较小的数量后停止划分（比如包围盒中只有5个三角形）

---

__brdf函数概念及实现（D G F）__

brdf函数接收两个参数，入射方向和出射方向，函数值表示从入射方向来的光有多少比例可以反射到出射方向

brdf由漫反射项和镜面反射项组成，漫反射项与入射方向和出射方向无关，通常为一个常数

镜面反射项包含三个重要部分：

F代表菲涅尔函数，表示从入射方向来的光有多少比例被反射，剩余的则发射折射

D代表法线分布函数，表示微表面的法线面向不同方向的概率，决定了镜面反射部分的宽度、形状以及其他特征

G代表几何函数，表示有多少比例的微表面能够同时被入射方向和反射方向看见，描述了模型的自遮挡情况



__radiance、irradiance、radiant intensity区别__

- 辐射强度(Radiant Intensity): 辐射强度是单位立体角由点光源发出的功率

- 辐照度(Irradiance)：辐照度是每(垂直/投影)单位面积入射到一个表面上一点的辐射通量(功率)

- 辐射(Radiance)：是指一个表面在每单位立体角、每单位投影面积上所发射(emitted)、反射(reflected)、透射(transmitted)或接收(received)的辐射通量(功率)

---

__影响游戏性能的因素及优化方法__

__影响因素__

cpu

- 过多的drawcall（限制cpu的主要因素，因为每次drawcall都会改变很多渲染状态的设置，非常耗费时间）
- 复杂的脚本或者物理模拟

gpu

- 过多的顶点
- 过多的顶点计算
- 过多的片元
- 过多的逐片元计算

带宽

- 使用了尺寸很大且未压缩的纹理
- 帧缓存分辨率过高

__优化方法__

cpu

- 通过批处理减少drawcall数量，批处理即尽可能的一次drawcall渲染多个物体，只有使用同一个材质的物体可以合并处理

gpu

- 减少需要处理的顶点数量

  - 需要美术优化模型，尽可能减少模型顶点数量

  - 模型LOD技术

  - 遮挡剔除技术（去除视锥内被完全遮挡的物体，区分视锥体剔除是去除不在视锥里的物体）

- 减少需要处理的片元数量，重点在于减少overdraw

  - 控制绘制顺序由近及远
  - 减少半透明物体
  - 减少实时光照和阴影

节省带宽

- 尽可能使用 mipmap 和纹理压缩
- 调整屏幕分辨率



__介绍一下MipMap__

多级渐远纹理，空间换时间，避免采用频率低和数据频率高造成的失真和摩尔纹现象

- 当物体离摄像机较远时，一个像素可能映射到 20x20 大小的纹理区域，此时使用邻近采样和线性采样则只能采样到一个小区域内的信息，造成失真，会出现锯齿和摩尔纹等结果，为了使得采样结果能顾及到原本应映射到的区域，同时保证运行时的速度，预先计算出分辨率逐渐降低的多级渐远纹理，在使用时，程序会查找最接近20x20纹理像素的多级渐远纹理，然后在这张纹理上再进行采样；为了更加精确，可以在两个最匹配的多级渐远纹理上进行采样，然后再在两者之间进行线性插值

---

__目前主流的抗锯齿方案（MSAA\SSAA\FXAA）__

- SSAA就是超采样，对于每一个像素再细分成多个子采样点，然后对每一个子采样点判断是否在三角形内、深度测试、着色计算，像素颜色就是所有子采样点颜色的平均，SSAA会使用更大的深度缓存和颜色缓存
- MSAA是根据像素本身计算颜色，然后根据子采样点的三角形覆盖百分比得到像素最终颜色

---

__mesh的数据结构是怎样的__

__介绍一下蒙皮动画__

- 通过在动画中直接修改bone的位置，让mesh的顶点随着bone的变化而变化，通常用于人形动画，如人物的跑动，跳跃等

__介绍一下 MVVM 和 MVC 设计模式__

__介绍一下IMR和TBR__

__什么是伽马校正__



---

#### 游戏引擎

__unity生命周期函数执行顺序__

- Awake->onEnable->Start->onTrigger->onMouse->Update->lateUpdate->onDisable->onDestroy



